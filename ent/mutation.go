// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sifu-box/ent/predicate"
	"sifu-box/ent/provider"
	"sifu-box/ent/ruleset"
	"sifu-box/ent/template"
	"sifu-box/singbox"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeProvider = "Provider"
	TypeRuleset  = "Ruleset"
	TypeTemplate = "Template"
)

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	_path         *string
	nodes         *[]map[string]interface{}
	appendnodes   []map[string]interface{}
	remote        *bool
	uuid          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Provider, error)
	predicates    []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id int) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProviderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Provider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProviderMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *ProviderMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ProviderMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *ProviderMutation) ResetPath() {
	m._path = nil
}

// SetNodes sets the "nodes" field.
func (m *ProviderMutation) SetNodes(value []map[string]interface{}) {
	m.nodes = &value
	m.appendnodes = nil
}

// Nodes returns the value of the "nodes" field in the mutation.
func (m *ProviderMutation) Nodes() (r []map[string]interface{}, exists bool) {
	v := m.nodes
	if v == nil {
		return
	}
	return *v, true
}

// OldNodes returns the old "nodes" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldNodes(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodes: %w", err)
	}
	return oldValue.Nodes, nil
}

// AppendNodes adds value to the "nodes" field.
func (m *ProviderMutation) AppendNodes(value []map[string]interface{}) {
	m.appendnodes = append(m.appendnodes, value...)
}

// AppendedNodes returns the list of values that were appended to the "nodes" field in this mutation.
func (m *ProviderMutation) AppendedNodes() ([]map[string]interface{}, bool) {
	if len(m.appendnodes) == 0 {
		return nil, false
	}
	return m.appendnodes, true
}

// ClearNodes clears the value of the "nodes" field.
func (m *ProviderMutation) ClearNodes() {
	m.nodes = nil
	m.appendnodes = nil
	m.clearedFields[provider.FieldNodes] = struct{}{}
}

// NodesCleared returns if the "nodes" field was cleared in this mutation.
func (m *ProviderMutation) NodesCleared() bool {
	_, ok := m.clearedFields[provider.FieldNodes]
	return ok
}

// ResetNodes resets all changes to the "nodes" field.
func (m *ProviderMutation) ResetNodes() {
	m.nodes = nil
	m.appendnodes = nil
	delete(m.clearedFields, provider.FieldNodes)
}

// SetRemote sets the "remote" field.
func (m *ProviderMutation) SetRemote(b bool) {
	m.remote = &b
}

// Remote returns the value of the "remote" field in the mutation.
func (m *ProviderMutation) Remote() (r bool, exists bool) {
	v := m.remote
	if v == nil {
		return
	}
	return *v, true
}

// OldRemote returns the old "remote" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemote: %w", err)
	}
	return oldValue.Remote, nil
}

// ResetRemote resets all changes to the "remote" field.
func (m *ProviderMutation) ResetRemote() {
	m.remote = nil
}

// SetUUID sets the "uuid" field.
func (m *ProviderMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ProviderMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ClearUUID clears the value of the "uuid" field.
func (m *ProviderMutation) ClearUUID() {
	m.uuid = nil
	m.clearedFields[provider.FieldUUID] = struct{}{}
}

// UUIDCleared returns if the "uuid" field was cleared in this mutation.
func (m *ProviderMutation) UUIDCleared() bool {
	_, ok := m.clearedFields[provider.FieldUUID]
	return ok
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ProviderMutation) ResetUUID() {
	m.uuid = nil
	delete(m.clearedFields, provider.FieldUUID)
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Provider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, provider.FieldName)
	}
	if m._path != nil {
		fields = append(fields, provider.FieldPath)
	}
	if m.nodes != nil {
		fields = append(fields, provider.FieldNodes)
	}
	if m.remote != nil {
		fields = append(fields, provider.FieldRemote)
	}
	if m.uuid != nil {
		fields = append(fields, provider.FieldUUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldName:
		return m.Name()
	case provider.FieldPath:
		return m.Path()
	case provider.FieldNodes:
		return m.Nodes()
	case provider.FieldRemote:
		return m.Remote()
	case provider.FieldUUID:
		return m.UUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldName:
		return m.OldName(ctx)
	case provider.FieldPath:
		return m.OldPath(ctx)
	case provider.FieldNodes:
		return m.OldNodes(ctx)
	case provider.FieldRemote:
		return m.OldRemote(ctx)
	case provider.FieldUUID:
		return m.OldUUID(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provider.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case provider.FieldNodes:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodes(v)
		return nil
	case provider.FieldRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemote(v)
		return nil
	case provider.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(provider.FieldNodes) {
		fields = append(fields, provider.FieldNodes)
	}
	if m.FieldCleared(provider.FieldUUID) {
		fields = append(fields, provider.FieldUUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	switch name {
	case provider.FieldNodes:
		m.ClearNodes()
		return nil
	case provider.FieldUUID:
		m.ClearUUID()
		return nil
	}
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldName:
		m.ResetName()
		return nil
	case provider.FieldPath:
		m.ResetPath()
		return nil
	case provider.FieldNodes:
		m.ResetNodes()
		return nil
	case provider.FieldRemote:
		m.ResetRemote()
		return nil
	case provider.FieldUUID:
		m.ResetUUID()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Provider edge %s", name)
}

// RulesetMutation represents an operation that mutates the Ruleset nodes in the graph.
type RulesetMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	_path           *string
	remote          *bool
	binary          *bool
	download_detour *string
	update_interval *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Ruleset, error)
	predicates      []predicate.Ruleset
}

var _ ent.Mutation = (*RulesetMutation)(nil)

// rulesetOption allows management of the mutation configuration using functional options.
type rulesetOption func(*RulesetMutation)

// newRulesetMutation creates new mutation for the Ruleset entity.
func newRulesetMutation(c config, op Op, opts ...rulesetOption) *RulesetMutation {
	m := &RulesetMutation{
		config:        c,
		op:            op,
		typ:           TypeRuleset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRulesetID sets the ID field of the mutation.
func withRulesetID(id int) rulesetOption {
	return func(m *RulesetMutation) {
		var (
			err   error
			once  sync.Once
			value *Ruleset
		)
		m.oldValue = func(ctx context.Context) (*Ruleset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ruleset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRuleset sets the old Ruleset of the mutation.
func withRuleset(node *Ruleset) rulesetOption {
	return func(m *RulesetMutation) {
		m.oldValue = func(context.Context) (*Ruleset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RulesetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RulesetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RulesetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RulesetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ruleset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RulesetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RulesetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ruleset entity.
// If the Ruleset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulesetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RulesetMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *RulesetMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *RulesetMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Ruleset entity.
// If the Ruleset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulesetMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *RulesetMutation) ResetPath() {
	m._path = nil
}

// SetRemote sets the "remote" field.
func (m *RulesetMutation) SetRemote(b bool) {
	m.remote = &b
}

// Remote returns the value of the "remote" field in the mutation.
func (m *RulesetMutation) Remote() (r bool, exists bool) {
	v := m.remote
	if v == nil {
		return
	}
	return *v, true
}

// OldRemote returns the old "remote" field's value of the Ruleset entity.
// If the Ruleset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulesetMutation) OldRemote(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemote: %w", err)
	}
	return oldValue.Remote, nil
}

// ResetRemote resets all changes to the "remote" field.
func (m *RulesetMutation) ResetRemote() {
	m.remote = nil
}

// SetBinary sets the "binary" field.
func (m *RulesetMutation) SetBinary(b bool) {
	m.binary = &b
}

// Binary returns the value of the "binary" field in the mutation.
func (m *RulesetMutation) Binary() (r bool, exists bool) {
	v := m.binary
	if v == nil {
		return
	}
	return *v, true
}

// OldBinary returns the old "binary" field's value of the Ruleset entity.
// If the Ruleset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulesetMutation) OldBinary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinary: %w", err)
	}
	return oldValue.Binary, nil
}

// ResetBinary resets all changes to the "binary" field.
func (m *RulesetMutation) ResetBinary() {
	m.binary = nil
}

// SetDownloadDetour sets the "download_detour" field.
func (m *RulesetMutation) SetDownloadDetour(s string) {
	m.download_detour = &s
}

// DownloadDetour returns the value of the "download_detour" field in the mutation.
func (m *RulesetMutation) DownloadDetour() (r string, exists bool) {
	v := m.download_detour
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadDetour returns the old "download_detour" field's value of the Ruleset entity.
// If the Ruleset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulesetMutation) OldDownloadDetour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadDetour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadDetour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadDetour: %w", err)
	}
	return oldValue.DownloadDetour, nil
}

// ClearDownloadDetour clears the value of the "download_detour" field.
func (m *RulesetMutation) ClearDownloadDetour() {
	m.download_detour = nil
	m.clearedFields[ruleset.FieldDownloadDetour] = struct{}{}
}

// DownloadDetourCleared returns if the "download_detour" field was cleared in this mutation.
func (m *RulesetMutation) DownloadDetourCleared() bool {
	_, ok := m.clearedFields[ruleset.FieldDownloadDetour]
	return ok
}

// ResetDownloadDetour resets all changes to the "download_detour" field.
func (m *RulesetMutation) ResetDownloadDetour() {
	m.download_detour = nil
	delete(m.clearedFields, ruleset.FieldDownloadDetour)
}

// SetUpdateInterval sets the "update_interval" field.
func (m *RulesetMutation) SetUpdateInterval(s string) {
	m.update_interval = &s
}

// UpdateInterval returns the value of the "update_interval" field in the mutation.
func (m *RulesetMutation) UpdateInterval() (r string, exists bool) {
	v := m.update_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateInterval returns the old "update_interval" field's value of the Ruleset entity.
// If the Ruleset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RulesetMutation) OldUpdateInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateInterval: %w", err)
	}
	return oldValue.UpdateInterval, nil
}

// ClearUpdateInterval clears the value of the "update_interval" field.
func (m *RulesetMutation) ClearUpdateInterval() {
	m.update_interval = nil
	m.clearedFields[ruleset.FieldUpdateInterval] = struct{}{}
}

// UpdateIntervalCleared returns if the "update_interval" field was cleared in this mutation.
func (m *RulesetMutation) UpdateIntervalCleared() bool {
	_, ok := m.clearedFields[ruleset.FieldUpdateInterval]
	return ok
}

// ResetUpdateInterval resets all changes to the "update_interval" field.
func (m *RulesetMutation) ResetUpdateInterval() {
	m.update_interval = nil
	delete(m.clearedFields, ruleset.FieldUpdateInterval)
}

// Where appends a list predicates to the RulesetMutation builder.
func (m *RulesetMutation) Where(ps ...predicate.Ruleset) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RulesetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RulesetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ruleset, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RulesetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RulesetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ruleset).
func (m *RulesetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RulesetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, ruleset.FieldName)
	}
	if m._path != nil {
		fields = append(fields, ruleset.FieldPath)
	}
	if m.remote != nil {
		fields = append(fields, ruleset.FieldRemote)
	}
	if m.binary != nil {
		fields = append(fields, ruleset.FieldBinary)
	}
	if m.download_detour != nil {
		fields = append(fields, ruleset.FieldDownloadDetour)
	}
	if m.update_interval != nil {
		fields = append(fields, ruleset.FieldUpdateInterval)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RulesetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ruleset.FieldName:
		return m.Name()
	case ruleset.FieldPath:
		return m.Path()
	case ruleset.FieldRemote:
		return m.Remote()
	case ruleset.FieldBinary:
		return m.Binary()
	case ruleset.FieldDownloadDetour:
		return m.DownloadDetour()
	case ruleset.FieldUpdateInterval:
		return m.UpdateInterval()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RulesetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ruleset.FieldName:
		return m.OldName(ctx)
	case ruleset.FieldPath:
		return m.OldPath(ctx)
	case ruleset.FieldRemote:
		return m.OldRemote(ctx)
	case ruleset.FieldBinary:
		return m.OldBinary(ctx)
	case ruleset.FieldDownloadDetour:
		return m.OldDownloadDetour(ctx)
	case ruleset.FieldUpdateInterval:
		return m.OldUpdateInterval(ctx)
	}
	return nil, fmt.Errorf("unknown Ruleset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RulesetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ruleset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ruleset.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case ruleset.FieldRemote:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemote(v)
		return nil
	case ruleset.FieldBinary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinary(v)
		return nil
	case ruleset.FieldDownloadDetour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadDetour(v)
		return nil
	case ruleset.FieldUpdateInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateInterval(v)
		return nil
	}
	return fmt.Errorf("unknown Ruleset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RulesetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RulesetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RulesetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ruleset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RulesetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ruleset.FieldDownloadDetour) {
		fields = append(fields, ruleset.FieldDownloadDetour)
	}
	if m.FieldCleared(ruleset.FieldUpdateInterval) {
		fields = append(fields, ruleset.FieldUpdateInterval)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RulesetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RulesetMutation) ClearField(name string) error {
	switch name {
	case ruleset.FieldDownloadDetour:
		m.ClearDownloadDetour()
		return nil
	case ruleset.FieldUpdateInterval:
		m.ClearUpdateInterval()
		return nil
	}
	return fmt.Errorf("unknown Ruleset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RulesetMutation) ResetField(name string) error {
	switch name {
	case ruleset.FieldName:
		m.ResetName()
		return nil
	case ruleset.FieldPath:
		m.ResetPath()
		return nil
	case ruleset.FieldRemote:
		m.ResetRemote()
		return nil
	case ruleset.FieldBinary:
		m.ResetBinary()
		return nil
	case ruleset.FieldDownloadDetour:
		m.ResetDownloadDetour()
		return nil
	case ruleset.FieldUpdateInterval:
		m.ResetUpdateInterval()
		return nil
	}
	return fmt.Errorf("unknown Ruleset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RulesetMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RulesetMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RulesetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RulesetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RulesetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RulesetMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RulesetMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ruleset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RulesetMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ruleset edge %s", name)
}

// TemplateMutation represents an operation that mutates the Template nodes in the graph.
type TemplateMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	dns                   *singbox.DNS
	log                   *singbox.Log
	route                 *singbox.Route
	inbounds              *[]map[string]interface{}
	appendinbounds        []map[string]interface{}
	outbound_groups       *[]singbox.OutboundGroup
	appendoutbound_groups []singbox.OutboundGroup
	ntp                   *singbox.Ntp
	experiment            *singbox.Experiment
	providers             *[]string
	appendproviders       []string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Template, error)
	predicates            []predicate.Template
}

var _ ent.Mutation = (*TemplateMutation)(nil)

// templateOption allows management of the mutation configuration using functional options.
type templateOption func(*TemplateMutation)

// newTemplateMutation creates new mutation for the Template entity.
func newTemplateMutation(c config, op Op, opts ...templateOption) *TemplateMutation {
	m := &TemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplateID sets the ID field of the mutation.
func withTemplateID(id int) templateOption {
	return func(m *TemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *Template
		)
		m.oldValue = func(ctx context.Context) (*Template, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Template.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemplate sets the old Template of the mutation.
func withTemplate(node *Template) templateOption {
	return func(m *TemplateMutation) {
		m.oldValue = func(context.Context) (*Template, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Template.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TemplateMutation) ResetName() {
	m.name = nil
}

// SetDNS sets the "dns" field.
func (m *TemplateMutation) SetDNS(s singbox.DNS) {
	m.dns = &s
}

// DNS returns the value of the "dns" field in the mutation.
func (m *TemplateMutation) DNS() (r singbox.DNS, exists bool) {
	v := m.dns
	if v == nil {
		return
	}
	return *v, true
}

// OldDNS returns the old "dns" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldDNS(ctx context.Context) (v singbox.DNS, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNS: %w", err)
	}
	return oldValue.DNS, nil
}

// ClearDNS clears the value of the "dns" field.
func (m *TemplateMutation) ClearDNS() {
	m.dns = nil
	m.clearedFields[template.FieldDNS] = struct{}{}
}

// DNSCleared returns if the "dns" field was cleared in this mutation.
func (m *TemplateMutation) DNSCleared() bool {
	_, ok := m.clearedFields[template.FieldDNS]
	return ok
}

// ResetDNS resets all changes to the "dns" field.
func (m *TemplateMutation) ResetDNS() {
	m.dns = nil
	delete(m.clearedFields, template.FieldDNS)
}

// SetLog sets the "log" field.
func (m *TemplateMutation) SetLog(s singbox.Log) {
	m.log = &s
}

// Log returns the value of the "log" field in the mutation.
func (m *TemplateMutation) Log() (r singbox.Log, exists bool) {
	v := m.log
	if v == nil {
		return
	}
	return *v, true
}

// OldLog returns the old "log" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldLog(ctx context.Context) (v singbox.Log, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLog: %w", err)
	}
	return oldValue.Log, nil
}

// ClearLog clears the value of the "log" field.
func (m *TemplateMutation) ClearLog() {
	m.log = nil
	m.clearedFields[template.FieldLog] = struct{}{}
}

// LogCleared returns if the "log" field was cleared in this mutation.
func (m *TemplateMutation) LogCleared() bool {
	_, ok := m.clearedFields[template.FieldLog]
	return ok
}

// ResetLog resets all changes to the "log" field.
func (m *TemplateMutation) ResetLog() {
	m.log = nil
	delete(m.clearedFields, template.FieldLog)
}

// SetRoute sets the "route" field.
func (m *TemplateMutation) SetRoute(s singbox.Route) {
	m.route = &s
}

// Route returns the value of the "route" field in the mutation.
func (m *TemplateMutation) Route() (r singbox.Route, exists bool) {
	v := m.route
	if v == nil {
		return
	}
	return *v, true
}

// OldRoute returns the old "route" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldRoute(ctx context.Context) (v singbox.Route, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoute: %w", err)
	}
	return oldValue.Route, nil
}

// ClearRoute clears the value of the "route" field.
func (m *TemplateMutation) ClearRoute() {
	m.route = nil
	m.clearedFields[template.FieldRoute] = struct{}{}
}

// RouteCleared returns if the "route" field was cleared in this mutation.
func (m *TemplateMutation) RouteCleared() bool {
	_, ok := m.clearedFields[template.FieldRoute]
	return ok
}

// ResetRoute resets all changes to the "route" field.
func (m *TemplateMutation) ResetRoute() {
	m.route = nil
	delete(m.clearedFields, template.FieldRoute)
}

// SetInbounds sets the "inbounds" field.
func (m *TemplateMutation) SetInbounds(value []map[string]interface{}) {
	m.inbounds = &value
	m.appendinbounds = nil
}

// Inbounds returns the value of the "inbounds" field in the mutation.
func (m *TemplateMutation) Inbounds() (r []map[string]interface{}, exists bool) {
	v := m.inbounds
	if v == nil {
		return
	}
	return *v, true
}

// OldInbounds returns the old "inbounds" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldInbounds(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInbounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInbounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInbounds: %w", err)
	}
	return oldValue.Inbounds, nil
}

// AppendInbounds adds value to the "inbounds" field.
func (m *TemplateMutation) AppendInbounds(value []map[string]interface{}) {
	m.appendinbounds = append(m.appendinbounds, value...)
}

// AppendedInbounds returns the list of values that were appended to the "inbounds" field in this mutation.
func (m *TemplateMutation) AppendedInbounds() ([]map[string]interface{}, bool) {
	if len(m.appendinbounds) == 0 {
		return nil, false
	}
	return m.appendinbounds, true
}

// ClearInbounds clears the value of the "inbounds" field.
func (m *TemplateMutation) ClearInbounds() {
	m.inbounds = nil
	m.appendinbounds = nil
	m.clearedFields[template.FieldInbounds] = struct{}{}
}

// InboundsCleared returns if the "inbounds" field was cleared in this mutation.
func (m *TemplateMutation) InboundsCleared() bool {
	_, ok := m.clearedFields[template.FieldInbounds]
	return ok
}

// ResetInbounds resets all changes to the "inbounds" field.
func (m *TemplateMutation) ResetInbounds() {
	m.inbounds = nil
	m.appendinbounds = nil
	delete(m.clearedFields, template.FieldInbounds)
}

// SetOutboundGroups sets the "outbound_groups" field.
func (m *TemplateMutation) SetOutboundGroups(sg []singbox.OutboundGroup) {
	m.outbound_groups = &sg
	m.appendoutbound_groups = nil
}

// OutboundGroups returns the value of the "outbound_groups" field in the mutation.
func (m *TemplateMutation) OutboundGroups() (r []singbox.OutboundGroup, exists bool) {
	v := m.outbound_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldOutboundGroups returns the old "outbound_groups" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldOutboundGroups(ctx context.Context) (v []singbox.OutboundGroup, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutboundGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutboundGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutboundGroups: %w", err)
	}
	return oldValue.OutboundGroups, nil
}

// AppendOutboundGroups adds sg to the "outbound_groups" field.
func (m *TemplateMutation) AppendOutboundGroups(sg []singbox.OutboundGroup) {
	m.appendoutbound_groups = append(m.appendoutbound_groups, sg...)
}

// AppendedOutboundGroups returns the list of values that were appended to the "outbound_groups" field in this mutation.
func (m *TemplateMutation) AppendedOutboundGroups() ([]singbox.OutboundGroup, bool) {
	if len(m.appendoutbound_groups) == 0 {
		return nil, false
	}
	return m.appendoutbound_groups, true
}

// ClearOutboundGroups clears the value of the "outbound_groups" field.
func (m *TemplateMutation) ClearOutboundGroups() {
	m.outbound_groups = nil
	m.appendoutbound_groups = nil
	m.clearedFields[template.FieldOutboundGroups] = struct{}{}
}

// OutboundGroupsCleared returns if the "outbound_groups" field was cleared in this mutation.
func (m *TemplateMutation) OutboundGroupsCleared() bool {
	_, ok := m.clearedFields[template.FieldOutboundGroups]
	return ok
}

// ResetOutboundGroups resets all changes to the "outbound_groups" field.
func (m *TemplateMutation) ResetOutboundGroups() {
	m.outbound_groups = nil
	m.appendoutbound_groups = nil
	delete(m.clearedFields, template.FieldOutboundGroups)
}

// SetNtp sets the "ntp" field.
func (m *TemplateMutation) SetNtp(s singbox.Ntp) {
	m.ntp = &s
}

// Ntp returns the value of the "ntp" field in the mutation.
func (m *TemplateMutation) Ntp() (r singbox.Ntp, exists bool) {
	v := m.ntp
	if v == nil {
		return
	}
	return *v, true
}

// OldNtp returns the old "ntp" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldNtp(ctx context.Context) (v singbox.Ntp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNtp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNtp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNtp: %w", err)
	}
	return oldValue.Ntp, nil
}

// ClearNtp clears the value of the "ntp" field.
func (m *TemplateMutation) ClearNtp() {
	m.ntp = nil
	m.clearedFields[template.FieldNtp] = struct{}{}
}

// NtpCleared returns if the "ntp" field was cleared in this mutation.
func (m *TemplateMutation) NtpCleared() bool {
	_, ok := m.clearedFields[template.FieldNtp]
	return ok
}

// ResetNtp resets all changes to the "ntp" field.
func (m *TemplateMutation) ResetNtp() {
	m.ntp = nil
	delete(m.clearedFields, template.FieldNtp)
}

// SetExperiment sets the "experiment" field.
func (m *TemplateMutation) SetExperiment(s singbox.Experiment) {
	m.experiment = &s
}

// Experiment returns the value of the "experiment" field in the mutation.
func (m *TemplateMutation) Experiment() (r singbox.Experiment, exists bool) {
	v := m.experiment
	if v == nil {
		return
	}
	return *v, true
}

// OldExperiment returns the old "experiment" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldExperiment(ctx context.Context) (v singbox.Experiment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperiment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperiment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperiment: %w", err)
	}
	return oldValue.Experiment, nil
}

// ClearExperiment clears the value of the "experiment" field.
func (m *TemplateMutation) ClearExperiment() {
	m.experiment = nil
	m.clearedFields[template.FieldExperiment] = struct{}{}
}

// ExperimentCleared returns if the "experiment" field was cleared in this mutation.
func (m *TemplateMutation) ExperimentCleared() bool {
	_, ok := m.clearedFields[template.FieldExperiment]
	return ok
}

// ResetExperiment resets all changes to the "experiment" field.
func (m *TemplateMutation) ResetExperiment() {
	m.experiment = nil
	delete(m.clearedFields, template.FieldExperiment)
}

// SetProviders sets the "providers" field.
func (m *TemplateMutation) SetProviders(s []string) {
	m.providers = &s
	m.appendproviders = nil
}

// Providers returns the value of the "providers" field in the mutation.
func (m *TemplateMutation) Providers() (r []string, exists bool) {
	v := m.providers
	if v == nil {
		return
	}
	return *v, true
}

// OldProviders returns the old "providers" field's value of the Template entity.
// If the Template object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplateMutation) OldProviders(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviders: %w", err)
	}
	return oldValue.Providers, nil
}

// AppendProviders adds s to the "providers" field.
func (m *TemplateMutation) AppendProviders(s []string) {
	m.appendproviders = append(m.appendproviders, s...)
}

// AppendedProviders returns the list of values that were appended to the "providers" field in this mutation.
func (m *TemplateMutation) AppendedProviders() ([]string, bool) {
	if len(m.appendproviders) == 0 {
		return nil, false
	}
	return m.appendproviders, true
}

// ClearProviders clears the value of the "providers" field.
func (m *TemplateMutation) ClearProviders() {
	m.providers = nil
	m.appendproviders = nil
	m.clearedFields[template.FieldProviders] = struct{}{}
}

// ProvidersCleared returns if the "providers" field was cleared in this mutation.
func (m *TemplateMutation) ProvidersCleared() bool {
	_, ok := m.clearedFields[template.FieldProviders]
	return ok
}

// ResetProviders resets all changes to the "providers" field.
func (m *TemplateMutation) ResetProviders() {
	m.providers = nil
	m.appendproviders = nil
	delete(m.clearedFields, template.FieldProviders)
}

// Where appends a list predicates to the TemplateMutation builder.
func (m *TemplateMutation) Where(ps ...predicate.Template) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Template, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Template).
func (m *TemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, template.FieldName)
	}
	if m.dns != nil {
		fields = append(fields, template.FieldDNS)
	}
	if m.log != nil {
		fields = append(fields, template.FieldLog)
	}
	if m.route != nil {
		fields = append(fields, template.FieldRoute)
	}
	if m.inbounds != nil {
		fields = append(fields, template.FieldInbounds)
	}
	if m.outbound_groups != nil {
		fields = append(fields, template.FieldOutboundGroups)
	}
	if m.ntp != nil {
		fields = append(fields, template.FieldNtp)
	}
	if m.experiment != nil {
		fields = append(fields, template.FieldExperiment)
	}
	if m.providers != nil {
		fields = append(fields, template.FieldProviders)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case template.FieldName:
		return m.Name()
	case template.FieldDNS:
		return m.DNS()
	case template.FieldLog:
		return m.Log()
	case template.FieldRoute:
		return m.Route()
	case template.FieldInbounds:
		return m.Inbounds()
	case template.FieldOutboundGroups:
		return m.OutboundGroups()
	case template.FieldNtp:
		return m.Ntp()
	case template.FieldExperiment:
		return m.Experiment()
	case template.FieldProviders:
		return m.Providers()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case template.FieldName:
		return m.OldName(ctx)
	case template.FieldDNS:
		return m.OldDNS(ctx)
	case template.FieldLog:
		return m.OldLog(ctx)
	case template.FieldRoute:
		return m.OldRoute(ctx)
	case template.FieldInbounds:
		return m.OldInbounds(ctx)
	case template.FieldOutboundGroups:
		return m.OldOutboundGroups(ctx)
	case template.FieldNtp:
		return m.OldNtp(ctx)
	case template.FieldExperiment:
		return m.OldExperiment(ctx)
	case template.FieldProviders:
		return m.OldProviders(ctx)
	}
	return nil, fmt.Errorf("unknown Template field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case template.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case template.FieldDNS:
		v, ok := value.(singbox.DNS)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNS(v)
		return nil
	case template.FieldLog:
		v, ok := value.(singbox.Log)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLog(v)
		return nil
	case template.FieldRoute:
		v, ok := value.(singbox.Route)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoute(v)
		return nil
	case template.FieldInbounds:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInbounds(v)
		return nil
	case template.FieldOutboundGroups:
		v, ok := value.([]singbox.OutboundGroup)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutboundGroups(v)
		return nil
	case template.FieldNtp:
		v, ok := value.(singbox.Ntp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNtp(v)
		return nil
	case template.FieldExperiment:
		v, ok := value.(singbox.Experiment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperiment(v)
		return nil
	case template.FieldProviders:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviders(v)
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Template numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(template.FieldDNS) {
		fields = append(fields, template.FieldDNS)
	}
	if m.FieldCleared(template.FieldLog) {
		fields = append(fields, template.FieldLog)
	}
	if m.FieldCleared(template.FieldRoute) {
		fields = append(fields, template.FieldRoute)
	}
	if m.FieldCleared(template.FieldInbounds) {
		fields = append(fields, template.FieldInbounds)
	}
	if m.FieldCleared(template.FieldOutboundGroups) {
		fields = append(fields, template.FieldOutboundGroups)
	}
	if m.FieldCleared(template.FieldNtp) {
		fields = append(fields, template.FieldNtp)
	}
	if m.FieldCleared(template.FieldExperiment) {
		fields = append(fields, template.FieldExperiment)
	}
	if m.FieldCleared(template.FieldProviders) {
		fields = append(fields, template.FieldProviders)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplateMutation) ClearField(name string) error {
	switch name {
	case template.FieldDNS:
		m.ClearDNS()
		return nil
	case template.FieldLog:
		m.ClearLog()
		return nil
	case template.FieldRoute:
		m.ClearRoute()
		return nil
	case template.FieldInbounds:
		m.ClearInbounds()
		return nil
	case template.FieldOutboundGroups:
		m.ClearOutboundGroups()
		return nil
	case template.FieldNtp:
		m.ClearNtp()
		return nil
	case template.FieldExperiment:
		m.ClearExperiment()
		return nil
	case template.FieldProviders:
		m.ClearProviders()
		return nil
	}
	return fmt.Errorf("unknown Template nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplateMutation) ResetField(name string) error {
	switch name {
	case template.FieldName:
		m.ResetName()
		return nil
	case template.FieldDNS:
		m.ResetDNS()
		return nil
	case template.FieldLog:
		m.ResetLog()
		return nil
	case template.FieldRoute:
		m.ResetRoute()
		return nil
	case template.FieldInbounds:
		m.ResetInbounds()
		return nil
	case template.FieldOutboundGroups:
		m.ResetOutboundGroups()
		return nil
	case template.FieldNtp:
		m.ResetNtp()
		return nil
	case template.FieldExperiment:
		m.ResetExperiment()
		return nil
	case template.FieldProviders:
		m.ResetProviders()
		return nil
	}
	return fmt.Errorf("unknown Template field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Template unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Template edge %s", name)
}
